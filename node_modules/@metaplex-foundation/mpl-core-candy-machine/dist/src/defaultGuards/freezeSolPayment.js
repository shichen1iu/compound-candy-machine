"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.freezeSolPaymentGuardManifest = void 0;
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const serializers_1 = require("@metaplex-foundation/umi/serializers");
const mpl_core_1 = require("@metaplex-foundation/mpl-core");
const errors_1 = require("../errors");
const generated_1 = require("../generated");
/**
 * The freezeSolPayment guard allows minting frozen NFTs by charging
 * the payer an amount in SOL. Frozen NFTs cannot be transferred
 * or listed on any marketplaces until thawed.
 *
 * The funds are transferred to a freeze escrow until all NFTs are thaw,
 * at which point, they can be transferred (unlocked) to the configured
 * destination account.
 *
 * @see {@link FreezeSolPaymentRouteArgs} to learn more about
 * the instructions that can be executed against this guard.
 */
exports.freezeSolPaymentGuardManifest = {
    name: 'freezeSolPayment',
    serializer: generated_1.getFreezeSolPaymentSerializer,
    mintParser: (context, mintContext, args) => {
        const [freezeEscrow] = (0, generated_1.findFreezeEscrowPda)(context, {
            destination: args.destination,
            candyMachine: mintContext.candyMachine,
            candyGuard: mintContext.candyGuard,
        });
        return {
            data: new Uint8Array(),
            remainingAccounts: [{ publicKey: freezeEscrow, isWritable: true }],
        };
    },
    routeParser: (context, routeContext, args) => {
        const { path } = args;
        switch (path) {
            case 'initialize':
                return initializeRouteInstruction(context, routeContext, args);
            case 'thaw':
                return thawRouteInstruction(context, routeContext, args);
            case 'unlockFunds':
                return unlockFundsRouteInstruction(context, routeContext, args);
            default:
                throw new errors_1.UnrecognizePathForRouteInstructionError('freezeSolPayment', path);
        }
    },
};
const initializeRouteInstruction = (context, routeContext, args) => {
    const [freezeEscrow] = (0, generated_1.findFreezeEscrowPda)(context, {
        destination: args.destination,
        candyMachine: routeContext.candyMachine,
        candyGuard: routeContext.candyGuard,
    });
    const serializer = (0, serializers_1.tuple)([(0, generated_1.getFreezeInstructionSerializer)(), (0, serializers_1.u64)()]);
    return {
        data: serializer.serialize([generated_1.FreezeInstruction.Initialize, args.period]),
        remainingAccounts: [
            { publicKey: freezeEscrow, isWritable: true },
            { signer: args.candyGuardAuthority, isWritable: false },
            { publicKey: (0, mpl_toolbox_1.getSplSystemProgramId)(context), isWritable: false },
        ],
    };
};
const thawRouteInstruction = (context, routeContext, args) => {
    const [freezeEscrow] = (0, generated_1.findFreezeEscrowPda)(context, {
        destination: args.destination,
        candyMachine: routeContext.candyMachine,
        candyGuard: routeContext.candyGuard,
    });
    const data = (0, generated_1.getFreezeInstructionSerializer)().serialize(generated_1.FreezeInstruction.Thaw);
    const remainingAccounts = [
        { publicKey: freezeEscrow, isWritable: true },
        { publicKey: args.asset, isWritable: true },
        { publicKey: args.collection, isWritable: true },
        { publicKey: (0, mpl_core_1.getMplCoreProgramId)(context), isWritable: false },
        { publicKey: (0, mpl_toolbox_1.getSplSystemProgramId)(context), isWritable: false },
    ];
    return { data, remainingAccounts };
};
const unlockFundsRouteInstruction = (context, routeContext, args) => {
    const [freezeEscrow] = (0, generated_1.findFreezeEscrowPda)(context, {
        destination: args.destination,
        candyMachine: routeContext.candyMachine,
        candyGuard: routeContext.candyGuard,
    });
    return {
        data: (0, generated_1.getFreezeInstructionSerializer)().serialize(generated_1.FreezeInstruction.UnlockFunds),
        remainingAccounts: [
            { publicKey: freezeEscrow, isWritable: true },
            { signer: args.candyGuardAuthority, isWritable: false },
            { publicKey: args.destination, isWritable: true },
            { publicKey: (0, mpl_toolbox_1.getSplSystemProgramId)(context), isWritable: false },
        ],
    };
};
//# sourceMappingURL=freezeSolPayment.js.map