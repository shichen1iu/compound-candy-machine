"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.freezeTokenPaymentGuardManifest = void 0;
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const serializers_1 = require("@metaplex-foundation/umi/serializers");
const mpl_core_1 = require("@metaplex-foundation/mpl-core");
const errors_1 = require("../errors");
const generated_1 = require("../generated");
/**
 * The freezeTokenPayment guard allows minting frozen NFTs by charging
 * the payer a specific amount of tokens from a certain mint acount.
 * Frozen NFTs cannot be transferred or listed on any marketplaces until thawed.
 *
 * The funds are transferred to a freeze escrow until all NFTs are thaw,
 * at which point, they can be transferred (unlocked) to the configured
 * destination account.
 *
 * @see {@link FreezeTokenPaymentRouteArgs} to learn more about
 * the instructions that can be executed against this guard.
 */
exports.freezeTokenPaymentGuardManifest = {
    name: 'freezeTokenPayment',
    serializer: generated_1.getFreezeTokenPaymentSerializer,
    mintParser: (context, mintContext, args) => {
        const [freezeEscrow] = (0, generated_1.findFreezeEscrowPda)(context, {
            destination: args.destinationAta,
            candyMachine: mintContext.candyMachine,
            candyGuard: mintContext.candyGuard,
        });
        const [tokenAddress] = (0, mpl_toolbox_1.findAssociatedTokenPda)(context, {
            mint: args.mint,
            owner: mintContext.minter.publicKey,
        });
        const [freezeAta] = (0, mpl_toolbox_1.findAssociatedTokenPda)(context, {
            mint: args.mint,
            owner: freezeEscrow,
        });
        return {
            data: new Uint8Array(),
            remainingAccounts: [
                { publicKey: freezeEscrow, isWritable: true },
                { publicKey: tokenAddress, isWritable: true },
                { publicKey: freezeAta, isWritable: true },
                { publicKey: (0, mpl_toolbox_1.getSplTokenProgramId)(context), isWritable: false },
            ],
        };
    },
    routeParser: (context, routeContext, args) => {
        const { path } = args;
        switch (path) {
            case 'initialize':
                return initializeRouteInstruction(context, routeContext, args);
            case 'thaw':
                return thawRouteInstruction(context, routeContext, args);
            case 'unlockFunds':
                return unlockFundsRouteInstruction(context, routeContext, args);
            default:
                throw new errors_1.UnrecognizePathForRouteInstructionError('freezeTokenPayment', path);
        }
    },
};
const initializeRouteInstruction = (context, routeContext, args) => {
    const [freezeEscrow] = (0, generated_1.findFreezeEscrowPda)(context, {
        destination: args.destinationAta,
        candyMachine: routeContext.candyMachine,
        candyGuard: routeContext.candyGuard,
    });
    const [freezeAta] = (0, mpl_toolbox_1.findAssociatedTokenPda)(context, {
        mint: args.mint,
        owner: freezeEscrow,
    });
    const serializer = (0, serializers_1.tuple)([(0, generated_1.getFreezeInstructionSerializer)(), (0, serializers_1.u64)()]);
    return {
        data: serializer.serialize([generated_1.FreezeInstruction.Initialize, args.period]),
        remainingAccounts: [
            { publicKey: freezeEscrow, isWritable: true },
            { signer: args.candyGuardAuthority, isWritable: false },
            { publicKey: (0, mpl_toolbox_1.getSplSystemProgramId)(context), isWritable: false },
            { publicKey: freezeAta, isWritable: true },
            { publicKey: args.mint, isWritable: false },
            { publicKey: (0, mpl_toolbox_1.getSplTokenProgramId)(context), isWritable: false },
            { publicKey: (0, mpl_toolbox_1.getSplAssociatedTokenProgramId)(context), isWritable: false },
            { publicKey: args.destinationAta, isWritable: true },
        ],
    };
};
const thawRouteInstruction = (context, routeContext, args) => {
    const [freezeEscrow] = (0, generated_1.findFreezeEscrowPda)(context, {
        destination: args.destinationAta,
        candyMachine: routeContext.candyMachine,
        candyGuard: routeContext.candyGuard,
    });
    const data = (0, generated_1.getFreezeInstructionSerializer)().serialize(generated_1.FreezeInstruction.Thaw);
    const remainingAccounts = [
        { publicKey: freezeEscrow, isWritable: true },
        { publicKey: args.asset, isWritable: true },
        { publicKey: args.collection, isWritable: true },
        { publicKey: (0, mpl_core_1.getMplCoreProgramId)(context), isWritable: false },
        { publicKey: (0, mpl_toolbox_1.getSplSystemProgramId)(context), isWritable: false },
    ];
    return { data, remainingAccounts };
};
const unlockFundsRouteInstruction = (context, routeContext, args) => {
    const [freezeEscrow] = (0, generated_1.findFreezeEscrowPda)(context, {
        destination: args.destinationAta,
        candyMachine: routeContext.candyMachine,
        candyGuard: routeContext.candyGuard,
    });
    const [freezeAta] = (0, mpl_toolbox_1.findAssociatedTokenPda)(context, {
        mint: args.mint,
        owner: freezeEscrow,
    });
    return {
        data: (0, generated_1.getFreezeInstructionSerializer)().serialize(generated_1.FreezeInstruction.UnlockFunds),
        remainingAccounts: [
            { publicKey: freezeEscrow, isWritable: true },
            { signer: args.candyGuardAuthority, isWritable: false },
            { publicKey: freezeAta, isWritable: true },
            { publicKey: args.destinationAta, isWritable: true },
            { publicKey: (0, mpl_toolbox_1.getSplTokenProgramId)(context), isWritable: false },
            { publicKey: (0, mpl_toolbox_1.getSplSystemProgramId)(context), isWritable: false },
        ],
    };
};
//# sourceMappingURL=freezeTokenPayment.js.map