"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nftMintLimitGuardManifest = void 0;
const mpl_toolbox_1 = require("@metaplex-foundation/mpl-toolbox");
const mpl_token_metadata_1 = require("@metaplex-foundation/mpl-token-metadata");
const generated_1 = require("../generated");
const guards_1 = require("../guards");
/**
 * The nftMintLimit guard allows to specify a limit on the
 * number of mints for a specific NFT mint.
 *
 * The limit is set per NFT mint, per candy machine and per
 * identified (provided in the settings) to allow multiple
 * NFT mint limits within a Candy Machine. This is particularly
 * useful when using groups of guards and we want each of them
 * to have a different NFT mint limit.
 */
exports.nftMintLimitGuardManifest = {
    name: 'nftMintLimit',
    serializer: generated_1.getNftMintLimitSerializer,
    mintParser: (context, mintContext, args) => {
        const tokenAccount = args.tokenAccount ??
            (0, mpl_toolbox_1.findAssociatedTokenPda)(context, {
                mint: args.mint,
                owner: mintContext.minter.publicKey,
            })[0];
        const [tokenMetadata] = (0, mpl_token_metadata_1.findMetadataPda)(context, { mint: args.mint });
        const [mintCounter] = (0, generated_1.findNftMintCounterPda)(context, {
            id: args.id,
            mint: args.mint,
            candyMachine: mintContext.candyMachine,
            candyGuard: mintContext.candyGuard,
        });
        return {
            data: new Uint8Array(),
            remainingAccounts: [
                { publicKey: mintCounter, isWritable: true },
                { publicKey: tokenAccount, isWritable: false },
                { publicKey: tokenMetadata, isWritable: false },
            ],
        };
    },
    routeParser: guards_1.noopParser,
};
//# sourceMappingURL=nftMintLimit.js.map