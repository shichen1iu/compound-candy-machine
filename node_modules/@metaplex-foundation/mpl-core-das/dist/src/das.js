"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.das = void 0;
const mpl_core_1 = require("@metaplex-foundation/mpl-core");
const constants_1 = require("./constants");
const helpers_1 = require("./helpers");
async function searchAssets(context, input) {
    const dasAssets = await context.rpc.searchAssets({
        ...input,
        interface: input.interface ?? constants_1.MPL_CORE_ASSET,
        burnt: false,
    });
    const mappedAssets = dasAssets.items.map((dasAsset) => (0, helpers_1.dasAssetToCoreAssetOrCollection)(dasAsset));
    if (input.interface === constants_1.MPL_CORE_COLLECTION || input.skipDerivePlugins) {
        return mappedAssets;
    }
    return (0, mpl_core_1.deriveAssetPluginsWithFetch)(context, mappedAssets);
}
function searchCollections(context, input) {
    return searchAssets(context, { ...input, interface: constants_1.MPL_CORE_COLLECTION });
}
function getAssetsByOwner(context, input) {
    return searchAssets(context, {
        ...input,
        owner: input.owner,
    });
}
function getAssetsByAuthority(context, input) {
    return searchAssets(context, {
        ...input,
        authority: input.authority,
    });
}
function getAssetsByCollection(context, input) {
    return searchAssets(context, {
        ...input,
        grouping: ['collection', input.collection],
    });
}
/**
 * Convenience function to fetch a single asset by pubkey
 * @param context Umi
 * @param asset pubkey of the asset
 * @param options
 * @returns
 */
async function getAsset(context, asset, options = {}) {
    const dasAsset = await context.rpc.getAsset(asset);
    return (await dasAssetsToCoreAssets(context, [dasAsset], options))[0];
}
/**
 * Convenience function to fetch a single collection by pubkey
 * @param context
 * @param collection
 * @returns
 */
async function getCollection(context, collection) {
    const dasCollection = await context.rpc.getAsset(collection);
    return dasAssetToCoreCollection(context, dasCollection);
}
function getCollectionsByUpdateAuthority(context, input) {
    return searchCollections(context, {
        ...input,
        authority: input.updateAuthority,
    });
}
async function dasAssetsToCoreAssets(context, assets, options) {
    const coreAssets = assets.map((asset) => {
        if (asset.interface !== constants_1.MPL_CORE_ASSET) {
            throw new Error(`Invalid interface, expecting interface to be ${constants_1.MPL_CORE_ASSET} but got ${asset.interface}`);
        }
        return (0, helpers_1.dasAssetToCoreAssetOrCollection)(asset);
    });
    if (options.skipDerivePlugins) {
        return coreAssets;
    }
    return (0, mpl_core_1.deriveAssetPluginsWithFetch)(context, coreAssets);
}
async function dasAssetToCoreCollection(context, asset) {
    if (asset.interface !== constants_1.MPL_CORE_COLLECTION) {
        throw new Error(`Invalid interface, expecting interface to be ${constants_1.MPL_CORE_COLLECTION} but got ${asset.interface}`);
    }
    return (0, helpers_1.dasAssetToCoreAssetOrCollection)(asset);
}
exports.das = {
    searchAssets,
    searchCollections,
    getAssetsByOwner,
    getAssetsByAuthority,
    getAssetsByCollection,
    getCollectionsByUpdateAuthority,
    getAsset,
    getCollection,
    dasAssetsToCoreAssets,
    dasAssetToCoreCollection,
};
//# sourceMappingURL=das.js.map