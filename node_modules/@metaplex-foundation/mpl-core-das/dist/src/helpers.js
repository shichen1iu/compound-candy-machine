"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dasAssetToCoreAssetOrCollection = void 0;
const mpl_core_1 = require("@metaplex-foundation/mpl-core");
const umi_1 = require("@metaplex-foundation/umi");
const constants_1 = require("./constants");
function convertSnakeCase(str, toCase = 'camel') {
    return str
        .toLowerCase()
        .split('_')
        .map((word, index) => toCase === 'camel' && index === 0
        ? word
        : word.charAt(0).toUpperCase() + word.slice(1))
        .join('');
}
function base64ToUInt8Array(base64) {
    return Uint8Array.from(atob(base64), (m) => m.charCodeAt(0));
}
function getUpdateAuthority(groupingItem, authority) {
    const result = {
        updateAuthority: { type: 'None' },
    };
    if (groupingItem && groupingItem.group_key === 'collection') {
        result.updateAuthority = {
            type: 'Collection',
            address: (0, umi_1.publicKey)(groupingItem.group_value),
        };
    }
    else {
        result.updateAuthority = {
            type: 'Address',
            address: authority.address,
        };
    }
    return result;
}
function getAccountHeader(executable, lamps, rentEpoch) {
    return {
        header: {
            executable: executable ?? false,
            owner: mpl_core_1.MPL_CORE_PROGRAM_ID,
            lamports: (0, umi_1.lamports)(lamps ?? -1),
            ...(rentEpoch !== undefined ? { rentEpoch: BigInt(rentEpoch) } : {}),
            exists: true,
        },
    };
}
function getRuleSet(dasRuleSet) {
    const isRuleSetString = typeof dasRuleSet === 'string';
    const ruleSetKind = isRuleSetString ? dasRuleSet : Object.keys(dasRuleSet)[0];
    const ruleSetData = !isRuleSetString && ruleSetKind
        ? dasRuleSet[ruleSetKind].map((bytes) => (0, umi_1.publicKey)(typeof bytes === 'string' ? bytes : new Uint8Array(bytes)))
        : [];
    // RuleSet has both __kind and type for backwards compatibility
    if (ruleSetKind === 'program_allow_list') {
        return {
            ...(0, mpl_core_1.ruleSet)('ProgramAllowList', [ruleSetData]),
            type: 'ProgramAllowList',
            addresses: ruleSetData,
        };
    }
    if (ruleSetKind === 'program_deny_list') {
        return {
            ...(0, mpl_core_1.ruleSet)('ProgramDenyList', [ruleSetData]),
            type: 'ProgramDenyList',
            addresses: ruleSetData,
        };
    }
    return {
        ...(0, mpl_core_1.ruleSet)('None'),
        type: 'None',
    };
}
function parseExtraAccount(data) {
    let result;
    Object.keys(data).forEach((key) => {
        const acc = data[key];
        const type = convertSnakeCase(key, 'pascal');
        switch (type) {
            case 'PreconfiguredProgram':
            case 'PreconfiguredCollection':
            case 'PreconfiguredOwner':
            case 'PreconfiguredRecipient':
            case 'PreconfiguredAsset':
                result = {
                    type,
                    isSigner: acc.is_signer,
                    isWritable: acc.is_writable,
                };
                break;
            case 'Address':
                result = {
                    type,
                    isSigner: acc.is_signer,
                    isWritable: acc.is_writable,
                    address: (0, umi_1.publicKey)(acc.address),
                };
                break;
            case 'CustomPda':
                result = {
                    type,
                    isSigner: acc.is_signer,
                    isWritable: acc.is_writable,
                    seeds: acc.seeds?.map((seed) => {
                        if (typeof seed === 'string') {
                            return {
                                type: seed,
                            };
                        }
                        if (seed.address) {
                            return {
                                type: 'Address',
                                pubkey: (0, umi_1.publicKey)(seed.address),
                            };
                        }
                        if (seed.bytes) {
                            return {
                                type: 'Bytes',
                                bytes: new Uint8Array(seed.bytes),
                            };
                        }
                        return null;
                    }),
                    customProgramId: acc.custom_program_id
                        ? (0, umi_1.publicKey)(acc.custom_program_id)
                        : undefined,
                };
                break;
            default:
        }
    });
    return result;
}
function parseLifecycleChecks(data) {
    return Object.keys(data).reduce((acc, key) => ({
        ...acc,
        [key]: data[key].map((check) => {
            switch (check) {
                case 'CanListen':
                    return mpl_core_1.CheckResult.CAN_LISTEN;
                case 'CanApprove':
                    return mpl_core_1.CheckResult.CAN_APPROVE;
                case 'CanReject':
                default:
                    return mpl_core_1.CheckResult.CAN_REJECT;
            }
        }),
    }), {});
}
function dasExternalPluginsToCoreExternalPlugins(externalPlugins) {
    return externalPlugins.reduce((acc, externalPlugin) => {
        const { authority, offset, type, adapter_config: adapterConfig, } = externalPlugin;
        const authorityAddress = authority?.address;
        if (type === 'Oracle') {
            if (!acc.oracles) {
                acc.oracles = [];
            }
            acc.oracles.push({
                type: 'Oracle',
                authority: {
                    type: authority.type,
                    ...(authorityAddress
                        ? { address: (0, umi_1.publicKey)(authorityAddress) }
                        : {}),
                },
                baseAddress: adapterConfig.base_address,
                resultsOffset: typeof adapterConfig.results_offset === 'string'
                    ? {
                        type: convertSnakeCase(adapterConfig.results_offset, 'pascal'),
                    }
                    : {
                        type: 'Custom',
                        offset: BigInt(adapterConfig.results_offset.custom),
                    },
                baseAddressConfig: adapterConfig.base_address_config
                    ? parseExtraAccount(adapterConfig.base_address_config)
                    : undefined,
                lifecycleChecks: externalPlugin.lifecycle_checks
                    ? parseLifecycleChecks(externalPlugin.lifecycle_checks)
                    : undefined,
                offset: BigInt(offset),
            });
        }
        return acc;
    }, {});
}
function dasPluginDataToCorePluginData(dasPluginData) {
    // TODO: Refactor when DAS types are defined
    return (({ basis_points, creators, rule_set, attribute_list, frozen, additional_delegates, number, max_supply, name, uri, signatures, }) => ({
        ...(basis_points !== undefined ? { basisPoints: basis_points } : {}),
        ...(creators !== undefined
            ? {
                creators: creators.map((creator) => ({
                    ...creator,
                    address: (0, umi_1.publicKey)(creator.address),
                })),
            }
            : {}),
        ...(rule_set !== undefined ? { ruleSet: getRuleSet(rule_set) } : {}),
        ...(attribute_list !== undefined ? { attributeList: attribute_list } : {}),
        ...(frozen !== undefined ? { frozen } : {}),
        ...(additional_delegates !== undefined
            ? { additionalDelegates: additional_delegates }
            : {}),
        ...(number !== undefined ? { number } : {}),
        ...(max_supply !== undefined ? { maxSupply: max_supply } : {}),
        ...(name !== undefined ? { name } : {}),
        ...(uri !== undefined ? { uri } : {}),
        ...(signatures !== undefined ? { signatures } : {}),
    }))(dasPluginData);
}
function dasPluginsToCorePlugins(dasPlugins) {
    return Object.keys(dasPlugins).reduce((acc, dasPluginKey) => {
        const dasPlugin = dasPlugins[dasPluginKey];
        const { authority, data, offset } = dasPlugin;
        const authorityAddress = authority?.address;
        acc = {
            ...acc,
            [convertSnakeCase(dasPluginKey)]: {
                authority: {
                    type: authority.type,
                    ...(authorityAddress ? { address: (0, umi_1.publicKey)(authorityAddress) } : {}),
                },
                ...dasPluginDataToCorePluginData(data),
                offset: BigInt(offset),
            },
        };
        return acc;
    }, {});
}
function handleUnknownPlugins(unknownDasPlugins) {
    if (!unknownDasPlugins)
        return {};
    return unknownDasPlugins.reduce((acc, unknownPlugin) => {
        if (!mpl_core_1.PluginType[unknownPlugin.type])
            return acc;
        const deserializedPlugin = (0, mpl_core_1.getPluginSerializer)().deserialize(base64ToUInt8Array(unknownPlugin.data))[0];
        const { authority } = unknownPlugin;
        const { address } = authority;
        const mappedPlugin = (0, mpl_core_1.mapPlugin)({
            plugin: deserializedPlugin,
            authority: {
                type: authority.type,
                ...(address ? { address } : {}),
            },
            offset: BigInt(unknownPlugin.offset),
        });
        acc = {
            ...acc,
            ...mappedPlugin,
        };
        return acc;
    }, {});
}
function handleUnknownExternalPlugins(unknownDasPlugins) {
    if (!unknownDasPlugins)
        return {};
    return unknownDasPlugins.reduce((acc, unknownPlugin) => {
        if (!mpl_core_1.ExternalPluginAdapterType[unknownPlugin.type])
            return acc;
        const deserializedPlugin = (0, mpl_core_1.getExternalPluginAdapterSerializer)().deserialize(base64ToUInt8Array(unknownPlugin.data))[0];
        const { authority, offset, lifecycle_checks: lifecycleChecks, } = unknownPlugin;
        const mappedPlugin = {
            lifecycleChecks: lifecycleChecks
                ? parseLifecycleChecks(lifecycleChecks)
                : undefined,
            authority,
            offset: BigInt(offset),
        };
        if (deserializedPlugin.__kind === 'Oracle') {
            if (!acc.oracles) {
                acc.oracles = [];
            }
            acc.oracles.push({
                type: 'Oracle',
                ...mappedPlugin,
                // Oracle conversion does not use the record or account data so we pass in dummies
                ...(0, mpl_core_1.oracleFromBase)(deserializedPlugin.fields[0], {}, new Uint8Array(0)),
            });
        }
        return acc;
    }, {});
}
function dasAssetToCoreAssetOrCollection(dasAsset) {
    const { interface: assetInterface, id, ownership: { owner }, content, compression: { seq }, grouping, authorities, plugins, unknown_plugins: unknownPlugins, executable, lamports: lamps, rent_epoch: rentEpoch, mpl_core_info: mplCoreInfo, external_plugins: externalPlugins, unknown_external_plugins: unknownExternalPlugins, } = dasAsset;
    const { num_minted: numMinted = 0, current_size: currentSize = 0 } = mplCoreInfo ?? {};
    const commonFields = {
        publicKey: id,
        uri: content.json_uri,
        name: content.metadata.name,
        content,
        ...getAccountHeader(executable, lamps, rentEpoch),
        ...(plugins ? dasPluginsToCorePlugins(plugins) : {}),
        ...(externalPlugins !== undefined
            ? dasExternalPluginsToCoreExternalPlugins(externalPlugins)
            : {}),
        ...handleUnknownPlugins(unknownPlugins),
        ...handleUnknownExternalPlugins(unknownExternalPlugins),
        // pluginHeader: // TODO: Reconstruct
    };
    const isCollection = assetInterface === constants_1.MPL_CORE_COLLECTION;
    if (isCollection) {
        return {
            ...commonFields,
            key: mpl_core_1.Key.CollectionV1,
            // Authority should be always present!
            updateAuthority: authorities[0].address,
            numMinted,
            currentSize,
        };
    }
    return {
        ...commonFields,
        key: mpl_core_1.Key.AssetV1,
        owner,
        seq: seq ? (0, umi_1.some)(BigInt(seq)) : (0, umi_1.none)(),
        // Authority should be always present!
        ...getUpdateAuthority(grouping[0], authorities[0]),
    };
}
exports.dasAssetToCoreAssetOrCollection = dasAssetToCoreAssetOrCollection;
//# sourceMappingURL=helpers.js.map